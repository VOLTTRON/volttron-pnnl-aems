{"version":3,"file":"static/js/617.39ede8fc.chunk.js","mappings":"iLAYaA,EAAQ,SAACC,EAAqCC,GACzD,KAAIC,EAAAA,EAAAA,OAAMF,MAAWG,EAAAA,EAAAA,SAAQH,GAA7B,CAGA,IAAII,EAAQ,IACRC,EAAAA,EAAAA,UAASL,KACXI,GAAQE,EAAAA,EAAAA,GAAcN,KAEpBO,EAAAA,EAAAA,UAASP,KACXI,EAAQI,KAAKC,UAAUT,IAEzB,IAAMU,EAAMF,KAAKT,MAAMK,GAiBvB,OAAOI,KAAKT,MAAMK,GAhBF,SAACO,EAAWC,GAC1B,GACEX,GACM,SAANU,KACCR,EAAAA,EAAAA,SAAQS,KACR,kEAAkEC,KAAKD,GAExE,MAAM,IAAIE,MAAJ,6HACkHF,EADlH,MAIR,OAAIG,EAAAA,EAAAA,KAAIH,EAAG,CAAC,UACHI,EAAAA,EAAAA,KAAIN,GAAKM,EAAAA,EAAAA,KAAIJ,EAAG,CAAC,SAASK,MAAM,KAAKC,MAAM,IAE7CN,Q,sDCtCX,IAAMO,EAAgBC,OAAO,iBACvBC,EAAeD,OAAO,gBAEtBE,EAAyB,iBAAM,IAC/BC,EAAsB,SAACC,EAAQC,EAAOC,GAAhB,OAAwBF,EAAON,MAAMO,EAAOC,GAAKC,QAAQ,MAAO,MAEtFC,EAAY,SAACC,EAAYC,GAI9B,IAHA,IAAIC,EAAQD,EAAgB,EACxBE,EAAiB,EAEQ,OAAtBH,EAAWE,IACjBA,GAAS,EACTC,GAAkB,EAGnB,OAAOC,QAAQD,EAAiB,IAGlB,SAASE,EAAkBL,GAAsC,6DAAJ,GAAI,IAAzBM,WAAAA,OAAyB,SAC/E,GAA0B,kBAAfN,EACV,MAAM,IAAIO,UAAJ,uEAAmFP,EAAnF,MAUP,IAPA,IAAMQ,EAAQF,EAAaZ,EAAsBD,EAE7CgB,GAAiB,EACjBC,GAAkB,EAClBC,EAAS,EACTC,EAAS,GAEJV,EAAQ,EAAGA,EAAQF,EAAWa,OAAQX,IAAS,CACvD,IAAMY,EAAmBd,EAAWE,GAC9Ba,EAAgBf,EAAWE,EAAQ,GAEzC,IAAKQ,GAAwC,MAArBI,EAA0B,CACjD,IAAME,EAAUjB,EAAUC,EAAYE,GACjCc,IACJP,GAAkBA,GAIpB,IAAIA,EAIJ,GAAKC,GAAmBI,EAAmBC,IAAkB,KAKtD,IAAIL,IAAoBpB,GAAiBwB,EAAmBC,IAAkB,OAAQ,CAE5FL,GAAkB,EAClBE,GAAUJ,EAAMR,EAAYW,IAF5BT,GAGAS,EAAST,EACT,SACM,GAAIQ,IAAoBpB,GAAsC,OAArBwB,EAC/CJ,GAAkB,EAClBE,GAAUJ,EAAMR,EAAYW,EAAQT,GACpCS,EAAST,MACH,KAAKQ,GAAmBI,EAAmBC,IAAkB,KAAM,CACzEH,GAAUZ,EAAWX,MAAMsB,EAAQT,GACnCS,EAAST,EACTQ,EAAkBlB,EAClBU,IACA,SACM,GAAIQ,IAAoBlB,GAAgBsB,EAAmBC,IAAkB,KAAM,CAEzFL,GAAkB,EAClBE,GAAUJ,EAAMR,EAAYW,IAF5BT,EAE4C,GAC5CS,EAAST,EAAQ,EACjB,gBAzBAU,GAAUZ,EAAWX,MAAMsB,EAAQT,GACnCS,EAAST,EACTQ,EAAkBpB,EAClBY,IA0BF,OAAOU,GAAUF,EAAkBF,EAAMR,EAAWX,MAAMsB,IAAWX,EAAWX,MAAMsB","sources":["utils/json.ts","../node_modules/strip-json-comments/index.js"],"sourcesContent":["import { get, has, isEmpty, isNil, isObject, isString } from \"lodash\";\nimport stripComments from \"strip-json-comments\";\n\n/**\n * Parse a json object and resolve all of the reference pointers.\n * Only absolute pointers are supported.\n * References must not be circular.\n *\n * @param schema the json object\n * @param validate true to throw an error if an issue occurs\n * @returns a dereferenced copy of the schema\n */\nexport const parse = (schema: string | object | undefined, validate?: boolean): object | undefined => {\n  if (isNil(schema) || isEmpty(schema)) {\n    return;\n  }\n  let input = \"\";\n  if (isString(schema)) {\n    input = stripComments(schema);\n  }\n  if (isObject(schema)) {\n    input = JSON.stringify(schema);\n  }\n  const ref = JSON.parse(input);\n  const reviver = (k: string, v: any): any => {\n    if (\n      validate &&\n      k === \"name\" &&\n      !isEmpty(v) &&\n      !/^([a-zA-Z_][a-zA-Z\\d_]*)((\\[\\d+\\])|(\\.[a-zA-Z_][a-zA-Z\\d_]*))*$/.test(v)\n    ) {\n      throw new Error(\n        `Name field must contain only container uppercase, lowercase, underscore, dot (path), and indices (array).\\nValue: \"${v}\"`\n      );\n    }\n    if (has(v, [\"$ref\"])) {\n      return get(ref, get(v, [\"$ref\"]).split(\"/\").slice(1));\n    }\n    return v;\n  };\n  return JSON.parse(input, reviver);\n};\n","const singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\n\nconst stripWithoutWhitespace = () => '';\nconst stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\\S/g, ' ');\n\nconst isEscaped = (jsonString, quotePosition) => {\n\tlet index = quotePosition - 1;\n\tlet backslashCount = 0;\n\n\twhile (jsonString[index] === '\\\\') {\n\t\tindex -= 1;\n\t\tbackslashCount += 1;\n\t}\n\n\treturn Boolean(backslashCount % 2);\n};\n\nexport default function stripJsonComments(jsonString, {whitespace = true} = {}) {\n\tif (typeof jsonString !== 'string') {\n\t\tthrow new TypeError(`Expected argument \\`jsonString\\` to be a \\`string\\`, got \\`${typeof jsonString}\\``);\n\t}\n\n\tconst strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;\n\n\tlet isInsideString = false;\n\tlet isInsideComment = false;\n\tlet offset = 0;\n\tlet result = '';\n\n\tfor (let index = 0; index < jsonString.length; index++) {\n\t\tconst currentCharacter = jsonString[index];\n\t\tconst nextCharacter = jsonString[index + 1];\n\n\t\tif (!isInsideComment && currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(jsonString, index);\n\t\t\tif (!escaped) {\n\t\t\t\tisInsideString = !isInsideString;\n\t\t\t}\n\t\t}\n\n\t\tif (isInsideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isInsideComment && currentCharacter + nextCharacter === '//') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = singleComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t\tcontinue;\n\t\t} else if (isInsideComment === singleComment && currentCharacter === '\\n') {\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (!isInsideComment && currentCharacter + nextCharacter === '/*') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = multiComment;\n\t\t\tindex++;\n\t\t\tcontinue;\n\t\t} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index + 1);\n\t\t\toffset = index + 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n}\n"],"names":["parse","schema","validate","isNil","isEmpty","input","isString","stripComments","isObject","JSON","stringify","ref","k","v","test","Error","has","get","split","slice","singleComment","Symbol","multiComment","stripWithoutWhitespace","stripWithWhitespace","string","start","end","replace","isEscaped","jsonString","quotePosition","index","backslashCount","Boolean","stripJsonComments","whitespace","TypeError","strip","isInsideString","isInsideComment","offset","result","length","currentCharacter","nextCharacter","escaped"],"sourceRoot":""}